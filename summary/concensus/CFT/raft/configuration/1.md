## implementation

- configuration change: leader don't append new cfg until commit all old cfg
- one step: old cfg and new cfg diff at most one server
- append time: use new cfg after append
- fix: leader don't append new cfg until commit entry (no-op) with same term

## proof

We proof by induction. We assume property is right for $\\{e_i\\}\_{1 \leq i \leq {n-1}}$, then we proof property is right for $\\{e_i\\}\_{1 \leq i \leq n}$.

定理1: log matching / cfg log matching

证明:

|                     | election | leader append | leader commit | follower append | follower commit | restart |
|---------------------|----------|---------------|---------------|-----------------|-----------------|---------|
| election safety     |          | x             | x             | x               | x               | x       |
| log matching        | x        | x             | x             | x               | x               | x       |

定理2: 最新的cfg之前的cfg已经commit

证明:

- election
- leader append: by configuration change
- leader commit
- follower append: by log matching
- follower commit
- restart

定理3: $C$ parent cfg, $C1$ commit child cfg, $C2$ slibing child cfg:

1. $\text{term}(C1) \leq \text{cterm}(C1)$
2. $\text{cterm}(C) \leq \text{term}(C2)$
3. $\text{term}(C2) \leq \text{term}(C1)$
4. election with cfg $C$ and term $T \Rightarrow \text{term}(C) \leq T \leq \text{term}(C1)$
5. election with cfg $C2$ and term $T \Rightarrow \text{term}(C) < T \leq \text{term}(C1)$, $T = \text{term}(C1)$ if and only if $C1 = C2$
