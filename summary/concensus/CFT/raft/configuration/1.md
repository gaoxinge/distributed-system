## implementation

- configuration change: leader don't append new cfg until commit all old cfg
- one step: old cfg and new cfg diff at most one server
- append time: use new cfg after append
- fix: leader don't append new cfg until commit entry (no-op) with same term

## proof

We proof by induction. We assume property is right for $\\{e_i\\}\_{1 \leq i \leq {n-1}}$, then we proof property is right for $\\{e_i\\}\_{1 \leq i \leq n}$.

定理1: log matching / cfg log matching

证明:

|                     | election | leader append | leader commit | follower append | follower commit | restart |
|---------------------|----------|---------------|---------------|-----------------|-----------------|---------|
| election safety     |          | x             | x             | x               | x               | x       |
| log matching        | x        | x             | x             | x               | x               | x       |

定理2: 最新的cfg之前的cfg已经commit

证明:

- election
- leader append: by configuration change
- leader commit
- follower append: by log matching
- follower commit
- restart

定理3: $C$ parent cfg, $C1$ commit child cfg, $C2$ slibing child cfg:

1. $\text{term}(C1) \leq \text{cterm}(C1)$
2. $\text{cterm}(C) \leq \text{term}(C2)$
3. $\text{term}(C2) \leq \text{term}(C1)$, $\text{term}(C2) = \text{term}(C1)$ iff $C1 = C2$
4. election with cfg $C$ and term $T \Rightarrow \text{term}(C) \leq T \leq \text{cterm}(C1)$
5. election with cfg $C2$ and term $T \Rightarrow \text{term}(C2) \leq T \leq \text{term}(C1)$, $T = \text{term}(C1)$ iff $C1 = C2$ 

证明:

1. by happen before
2. by configuration change
3.

(a) we assume

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$
- $N2: [C_T^{\text{commit}}, C2_{T_2}]$

with $T_2 > T_1$

go to (b)

(b) by fix

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$
- $N2: [C_T^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}, C2_{T_2}]$

with

- $C1$ commit with cfg $C1$ and term $T_1'$, after election with $C1'$ and term $T_1'$
- $\text{no-op}$ commit with cfg $C$ and term $T_2$, after election with $C$ and term $T_2$

go to (c1) or (d1)

(c1) $T_1' > T_2$

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$
- $N2: [C_T^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}, C_{T_2}]$

with

- $C1$ commit after election with cfg $C1'$ and term $T_1'$
- $\text{no-op}$ commit with cfg $C$ and term $T_2$

go to (c2)

(c2) becasuse $C1' = C1$, there is a voter for $C1'$ and $C$. so we have

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}]$
- $N2: [C_T^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}, C_{T_2}]$

go to (c3)

(c3) by log matching

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}]$
- $N2: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}, C_{T_2}]$

Q.E.D.

(d1) $T_1' < T_2$

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$
- $N2: [C_T^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}, C2_{T_2}]$

with

- $C1$ commit with cfg $C1$ and term $T_1'$
- $\text{no-op}$ commit after election with $C$ and term $T_2$

go to (d2)

(d2) there is a voter for $C1$ and $C$. so we have

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$
- $N2: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}, \text{no-op}\_{T_2}^{\text{commit}}, C2_{T_2}]$

Q.E.D.

4. 

(a) we assume
  
- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$ 
- $N2: [C_T^{\text{commit}}]$

with 

- $N1$ commit $C1$ with cfg $C1$ and term $T_1'$
- $N2$ election with cfg $C$ and term $T'$
- $T' > T_1'$

go to (b)

(b) there is a voter for $C1$ and $C$. so we have

- $N1: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$ 
- $N2: [C_T^{\text{commit}}, C1_{T_1}^{\text{commit}}]$

Q.E.D.

5. 

(a) we assume

- $N1: [C_T^\text{commit}, C1_{T_1}^\text{commit}]$
- $N2: [C_T^\text{commit}, C2_{T_2}]$

with 

- $N2$ election with $C2$ and $T_2'$ and $T_2' > T_1$

go to (b)

(b) by 结论3 and by fix

- $N1: [C_T^\text{commit}, \text{no-op}\_{T_1}^\text{commit}, C1_{T_1}^\text{commit}]$
- $N2: [C_T^\text{commit}, C2_{T_2}]$

with

- $N1$ commit $\text{no-op}$ with cfg $C$ and term $T_1$

go to (c)

(c) there is a voter for $C2$ and $C$. so we have

- $N1: [C_T^\text{commit}, \text{no-op}\_{T_1}^\text{commit}, C1_{T_1}^\text{commit}]$
- $N2: [C_T^\text{commit}, C2_{T_2}, \text{no-op}\_{T_1}^\text{commit}]$

go to (d)

(d) by log matching

- $N1: [C_T^\text{commit}, C2_{T_2}, \text{no-op}\_{T_1}^\text{commit}, C1_{T_1}^\text{commit}]$
- $N2: [C_T^\text{commit}, C2_{T_2}, \text{no-op}\_{T_1}^\text{commit}]$
  
Q.E.D. 
